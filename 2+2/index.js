import { validateData } from './modules/validator.js';
import { sum, insertAfter, isElemExistByID, isElemExistByClassName } from './modules/helpers.js';

const COUNT_INPUTS = 2;
//4.4. как было указано в задании у сообщения "Это не число" должен быть className - error-message, как мы выучили ранее у нас вся страничка в браузере - дерево связей, по этому мы можем легко найти узлы по нужному нам className - error-message, и удалить найденный узел и тогда у пользователя на страничке пропадет надпись "Это не число"
const clearErrors = () => {
  isElemExistByClassName('error-message') &&
    [...document.getElementsByClassName('error-message')].forEach((elem) => {
      elem.remove();
    });
};
//все также как и в 4.4, только className - result
const clearResult = () => {
  isElemExistByID('result') && document.getElementById('result').remove();
};
//4.6
const notValidInputs = (errors) => {
  //если в поля ввода пользватель вводил не валидные числа то нам с validateData возвращается объект с свойствами какое из полей не валидно и с текстом , что нам нужно отобразить под полем ввода(как помним errors может выглядить так {input1: "Это не число",input2:"Это не число"})
  for (const key in errors) {
    //мы проходимся по errors с помощью цикла for in, он похож на простой for, которой был в части 5. И так key - это наше свойство\ключ (input1,input2)
    if (errors.hasOwnProperty(key)) {
      const div = document.createElement('div'); //создаем новый узел div
      div.className = 'error-message'; //указываем для этого узла className - error-message, className похож на id , но на страничке может быть много узлов с одинаковым значением className, id только один
      div.innerHTML = errors[key]; // отображаем на страничке сообщение ("Это не число") которое мы получаем по свойству
      const input = document.getElementById(key); //и нам опять нужно настроить связи в дереве dom, мы находим узел input1(или input2 в зависимости от того на какой мы итерации в цикле и какой у нас key)
      insertAfter(div, input); //и приклеиваем после узла поля ввода узел с сообщением "Это не число"
      //                              было html -> body-> div->input
      //                                                     ->input
      //                                                     ->btn
      //стало html -> body-> div->input
      //                        -> div c className - error-message
      //                        ->input
      //                        ->btn
      //ну или добавится после 2го инпута или вообще и там и там, в зависимости что вводил пользователь в поля ввода
    }
  }
};
//4.2
const getInputsValue = () => {
  const input1 = document.getElementById('input1'); // document.getElementById, что же это за метод? все просто, мы по уникальному id ищем наш узел, id у него "input1" как помнишь мы сами его и создавали)
  const input2 = document.getElementById('input2'); //ну тут также
  return { input1: input1.value, input2: input2.value }; //как раньше мы обусловились функция это последовательность исполнения команд в коде(часть 2), но функция может еще возвращать какой-то результат\значение(как в нашем случае) мы возвращаем объект со значениями, которые мы получили выше
  //что же такое этот объект, технически это один из типов данных "Object" в языке javascript(всего их 8 сейчас можно тут почитать https://learn.javascript.ru/types), а по факту это удобная структура для хранения каких то данных, логика такая, что у объекта есть свойства по которым можно получить значение, давай посмотрим на наш пример {input1: some_value, input2: some_value}, как видим у нас объект состоит из двух свойств\ключей - input1,input2(для удобства мы зназвали их как и id). при их обращении мы сможем получить их значения(в нашем случае это содержимое, введенное в поле ввода на страничке в браузера)
};
//4.1  как помним мы говорили о btnListener, эта функция вызывается\срабатывает каждый раз, как пользователь нажимает  кнопку "Посчитать", давай подробнее о том, что тут происходит, так как тут вся основная логика
const btnListener = () => {
  const { input1, input2 } = getInputsValue(); //тут мы вызываем функцию getInputsValue которая возвращает два значения с каждого поля ввода (смотри 4.2), так как ты прочитала в части 4.2, getInputsValue вернуло объект с нашими значениями с полей ввода, и для удобства мы его "распечатываем" в две переменные input1,input2(програмнная еденица хранения данных), еще  мы могли написать так some_obj = getInputsValue() и тогда чтобы получить значение, к примеру с первого поля ввода, мы бы писали так some_obj.input1. Но удобней использовать такие "распечатывания" если свойств у объекта немного. технически это называется Деструктуризация
  const { isValid, errors } = validateData({
    //хорошо, теперь нам нужно проверить наши значения с полей ввода, подходят ли они под наши критерии(нам нужны только числа, ни буквы, ни символы .+-№;?:)
    input1,
    input2,
  }); // функция validateData вернула нам вновь объект, который мы "распечатали" в части 4.3 я описал , что такое isValid и errors(файл modules/validator.js)

  //ниже 2 функции. если пользователь пробовал ранее воспользоваться нашим калькулятором, то на страничке могут быть сообщения с результатом сложения предыдущих чисел , или одно из сообщений, что введеное значение "Не число". нам необходимо очистить эти сообщения перед тем как выводить пользователю что-то новое, если же этих сообщений не было на страничке браузера, то и чистить нечего)
  clearErrors(); //для очистки сообщений "Это не число" для полей ввода (4.4)
  clearResult(); // для очистки результата сложения от предыдущих подсчетов (4.5)

  if (!isValid) {
    //если isValid равен false(как помним это зависит от того, что мы ввели в поля ввода) то исполнятся две нижние строчки, если нет, то обе пропустятся
    notValidInputs(errors); //эта функция для того чтобы создать узел с id - error-message и отобразить его на страничке (4.6)
    return; //если isValid равен false, то тут программа останавливается и код ниже не исполняется, так как уже пользователю отобразилось сообщение "Это не число"
  } //если же isValid равен true, то мы блок выше пропустили, значит можно переходить к суммированию наших чисел и ввыводить результат на страничке
  const btn = document.getElementById('btn'); //нашли нашу кнопку по id - btn
  const result = document.createElement('div'); //создали новый узел
  result.setAttribute('id', 'result'); // добавили к нашему узлу id - result
  result.innerHTML = sum(input1, input2); // на страничке в браузере отобразится сумма двух чисел
  insertAfter(result, btn); //а эту функцию мы вызываем чтобы сделать связь в dom  дереве, для этого мы и искали узел btn, мы после узла btn приклеиваем наш новый узел с результатом суммы чисел. было html -> body-> div->input
  //                                                     ->input
  //                                                     ->btn
  //стало html -> body-> div->input
  //                        ->input
  //                        ->btn
  //                        ->div c id result
};

//часть 5. снова все схожее, создать узел, приклеить его к другому узлу
const initInputs = (container) => {
  //по скольку у нас должно быть 2 поля ввода, то мы для удобства проходимся по циклу(цикл это повторение одних и тех же команд с счетчиком, в нашем примере счетчик от 1 до COUNT_INPUTS, то есть до 2х), мы используем цикл для того чтобы избежать написания одинакового куска кода дважды
  for (let i = 1; i <= COUNT_INPUTS; i++) {
    const input = document.createElement('INPUT'); //создаем узел input
    input.setAttribute('id', `input${i}`); //добавляем ему id - input1(для второго будет input2)
    input.setAttribute('type', 'text'); //нам нужно задать тип для наших полей ввода, они бывают разные, самыё известный, это text - обобщенный, для любого текста подходит
    container.appendChild(input); //ну и также приклеиваем наши два узла к узлу div с id - container
  } //теперь структура такая: html -> body-> div->btn
}; //                                            ->input
//                                               ->input
// это значит, что у узла div теперь 3 потомка  И так, пока подытожим, с 2й по 5й части у нас все срабатывало автоматически при загрузке нашей страничке, собственно построилось наше дерево связей и ты можешь увидеть на страничке 2 поля ввода для чисел и кнопку "посчитать", дальше мы будем рассматривать, что будет происходить при взаимодействии с программой(то есть, что происходит при нажатии на кнопку, при нажатии на поле ввода и печатании числа и тд)

//часть 4, так тут все очень похоже как с частью 3, нам нужно создать узел и приклеить его к другому узлу для связей, давай подробнее посмотрим на нашу функцию
const initBtn = (container) => {
  const btn = document.createElement('BUTTON'); //ну тут мы создаем узел button
  btn.setAttribute('id', 'btn'); //задаем уникальный id "btn"
  btn.innerHTML = 'Посчитать'; //смотри, вот эта важная детать, у узла есть свойство(innerHTML) это то ,что будет отображаться непосредственно на страничке, надпись на нашей кнопке
  container.appendChild(btn); //как помнишь в часте 3 мы цепляли узел div c id-container к body, а тут нам нужно прицепить наш узел кнопку к тому самому container, теперь часть дерева выглядить так: html->body->div->button
  btn.onclick = btnListener; //тоже очень важная строка, когда мы мышкой нажимаем на кнопку, должно что-то произойти, технически это называется: на узел button навесить событие onclick, при срабатывании этого события(при нажатии на кнопку) вызывается другая функция btnListener (о ней чуть позже: часть 4.1), смотри пока дальше часть 5
};

//часть 3. так как мы узучили в часте 1, у нас страница состоит из множеста узлов в виде дерева. Одна из главных веток это body как мы поняли. Ниже у нас функция, которая создает еще один узел div и приклеивает, цепляет его к body, теперь связь такая: html -> body -> div, теперь у body есть потомок - div, а у div есть отец - body(они связанные между собой)
const initContainer = () => {
  const container = document.createElement('div'); // создали узел
  container.style.display = 'table-caption'; //применили некоторые стили , в принципе не важные, это строка так меняет часть страницы нашей, что все узлы внутри будут одним столбцом(на скриншоте будет видно)
  container.setAttribute('id', 'container'); //это важная строка, мы нашему новому узлу создаем id(уникальный ключ, для удобства все называют его контейнером)
  document.body.appendChild(container); //ну и как я написал выше нам необходимо прицепить наш новый узел к body, чтобы образовалась связь, переходим к части 4
  return container;
};

//2 часть. тут начинает запускаться наш код, скажем это точка старта когда загружается страничка, для удобства мы написали 3 функции(функция это последовательность исполнения команд в коде, так же как и в жизни, у нас есть функции питания, ходьбы и так далее)
(() => {
  const container = initContainer(); // смотри часть 3
  initInputs(container); //смотри часть 4
  initBtn(container); //смотри часть 5
})();
//1 часть
//и так данная лаб. работа это калькулятор сложения чисел, нам нужно было создать два поля ввода для каждого числа и кнопку - "посчитать", собственно для вычисления результата. если в поля были введены не валидные значения(например буквы или символы такие как .?:;№" и так далее) то под полем ввода долждна появиться надпись -  "это не число" (увидишь на скриншоте). если же все хорошо и были введены числа (ну к примеру 1 и 4.5) то под кнопкой - "Посчитать" при ее нажатии появится результат сложения чисел (5.5)
//теперь немного теории,она важна для понимания программы и преподаватель может что-то из этого спросить, и так смотри, каждая страница в браузере, в интернете состоит из множества узлов (nodes), узлы бывают разные, текстовые (div,h1,h2...h6,p и так далее), кнопки(button), поля ввода(input), бывают и множество других (img для картинок к примеру) мы же рассмотрим те которые использутся в этой лабе(div, button, input)
//так давай подробнее остановимся на этих узлах, что это все же такое? вся твоя страница(любая, этот калькулятор, любой сайт, блог и так далее) состоит из дерева этих узлов, они между собой связные. дерево в прямом смысле ---- у нас есть корень html и от него идут ветки, к примеру одна из веток body, а от body идет еще много веток узлов div,button, input. если посмотришь внутри файлика index.html, то увидишь, что там body пустой и нам нужно было с помощью javascript все узлы создавать ручками(в этом от части суть всех лаб работ, научить студентов работать с этим деревом, его еще называют dom дерево, через код, мы написали много функций для этого)
//
