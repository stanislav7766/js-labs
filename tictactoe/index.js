import Command from './modules/command.js';
import History from './modules/history.js';
import { State, WIN_LINES } from './modules/data.js';
import { hideElement, getData, setData, activeBtn, disableBtn } from './modules/helpers.js';
//для синхроницации между вкладками мы используем BroadcastChannel. логика похожа с кнопками узлами, как помнишь мы на кнопку навешивали событие, что при нажатии на кнопку будет вызываться функция. тут также, мы открыли канал, ниже в коде мы навесим событие onmessage и когда будет нужно, сможем отправлять сообщения для синхронизации, и во всех вкладках, где открыта игра, будут приходить эти сообщения
const Share = new BroadcastChannel('test_channel');
// предисловие
// и так давай крестики нолики, основные требования: синхронизация между вкладками, при перезагрузки страницы незавершенная игра продолжается, начать новую игру без перезвгрузки стр, возможность делать шаг назад и вперед во время игры
// все стили уже прописаны до нас(в файлике style.css)мы лишь обеспечиваем функциональность, то есть в нужный момент мы у узла будем менять\добавлять classNames

//для обеспечения хода назад и вперед у нас будет история игры с состоянием хода. это значит, что в процессе игры мы точно будем знать, какой ход был предыдущий, что следующий ход будет крестик, если предыдущий нолик и тд
let history = new History(State());
// мы написали такую вот функцию MakeSync для синхронизации игры. как помнишь в списке дел мы использовали хранилище localStorage) тут тоже, но там мы хранили записи списка дел, а тут храним всю историю ходов(соответсвенно каждый ход мы обновляем историю в хранилище)
// хорошо, что по коду
const MakeSync = (type) => {
  setData(history); //записываем всю историю ходов в хранилище
  Share.postMessage(type); //и отправляем сообщение по нашему каналу, отправляем переданный тип, о типах чуть позже, но суть в том, что под определенный тип - свой сценарий событий
};

const statusGame = () => {
  if (calculateWinner(history.state.squares)) return 1;
  else if (history.current == 8) return 2;
  else return 0;
};
// statusGame, checkEndGame - две не сильно важные функции, но написаны для удобства, их задача по текущему состоянию хода (history state) проверить статус игры, завершенная игра или нет

const checkEndGame = (status = statusGame()) => status === 1 || status === 2;

//render важная функция для понимания логики в целом, вызывается практически везде,в обработчике каждой кнопки, при старте игры, при синхронизации между вкладками. У нас в истории ходов в состоянии текущего хода хранится массив из 9 элементов - наши квадратики(как и пустые, помеченные крестом и ноликом)
// и вот логика такая, что когда нужно отобразить изменения, то мы проходимся по этим квадратикам в нашей истории, и в зависимости от содержимого, меняем у узла на страничке его className,(а как мы помним, когда мы меняем его, то применяются разные стили)
// еще раз, цепочка событий такая: мы нажали на пустой квадратик или кнопку любую->изменилась история игры->в состоянии пометился конкретно тот квадратик крестиком или ноликом->вызвался render и вот только в этот момент на страничке произошли визуальные изменения и наш ход отобразился в игре

// какой className меняется написано в задании
const render = () => {
  history.state.squares.forEach((val, i) => {
    const node = document.querySelector(`[data-id="${i}"]`);
    val === '' ? (node.className = 'cell') : (node.className = `cell ${val === 'X' ? 'ch' : 'r'}`);
  });
  checkButtons();
  checkEndGame() && endGame(); //так же проверка в каждом рендере, если последний сделанный ход был завершающим, то вызовем endGame(глянь описание его)
};

const checkButtons = () => {
  history.canUndo() ? activeBtn('undo-btn') : disableBtn('undo-btn');
  history.canRedo() ? activeBtn('redo-btn') : disableBtn('redo-btn');
};
//слушатель для кнопки назад, когда нажимаешь на нее, то вызывается эта функция
const undoBtnListener = () => {
  checkEndGame() && hideElement('won-title'); //если была завершена игра пеед тем как мы нажали назад, то мы спрячем верхюю панель с надписью и кнопкой рестарт, так как теперь игра считается не завершенная
  history.undo(); //делаем в истории шаг назад, меняется наше состояние хода
  MakeSync('step'); //отправляем по каналу сообщение, чтобы в других вкладках тоже добавился новый ход
  render(); //и рендер, то есть отобразить ход на страничке браузера
};
//слушатель для кнопки вперед, когда нажимаешь на нее, то вызывается эта функция. Похоже все с кнопкой назад
const redoBtnListener = () => {
  history.redo();
  MakeSync('step');
  render();
  checkEndGame() && endGame();
};
//слушатель для кнопки рестарт, когда нажимаешь на нее, то вызывается эта функция
const restartBtnListener = () => {
  checkEndGame() && hideElement('won-title'); //прячем верхнюю панельку, так как начинается новая игра
  history.finishGame(); //завершаем прошлую игру
  history.setDefault(State()); //начинаем новую
  MakeSync('restart'); //отправляем по каналу сообщение, чтобы в других вкладках тоже началасб новая игра
  render(); //и рендер, то есть отобразить начало новой игры на страничке браузера
};
//вызов этой функции отобразит на странице браузера завершение игры(выигранные квадратики перечеркнуться линией, появиться кнопка рестарт и надпись победителя
const endGame = () => {
  const node = document.getElementsByClassName('won-title')[0]; //поиск узла на странице, который всю игру был спрятян(присутствовал className hidden)
  node.className = 'won-title'; //и заменем className на won-title и соответственно hidden пропадет и на странице появится верхняя панелька с рестартом игры и надписью победителя игры
  const textNode = document.getElementsByClassName('won-message')[0]; //поиск узла, что отвечает за надпись победителя
  const status = statusGame(); //проверяем статус игры
  textNode.innerHTML = status === 2 ? `It's a draw!` : history.state.xIsNext ? `Toes won!` : `Crosses won!`; //и в зависимости от того чей был послелний победный ход(ну или ничья ), отобразим на странице сооветствующую надпись

  if (status === 1) {
    //если игра закончилась победой, а не ничьей, то мы по истории определяем тип линии для зачеркивания квадратов(диагональ, горизонтальная или вертикальная)
    const line = calculateWinner(history.state.squares);
    line.indexes.forEach((index) => {
      //ну и проходимся по нашим выиграшных квадратиках меняя у нужного узла className, добавляя как раз ту самую линию, и сразу же изменения отображаются на страничке
      const node = document.querySelector(`[data-id="${index}"]`);
      node.className = `${node.className} win ${line.type}`;
    });
  }
};
//слушатель для ячеек, когда нажимаешь на квадратик, то вызывается эта функция
//все максимально просто: проверить не конец игры ли, если конец, то ничего дальше не происходит, так как нам незачем добавлять крестик или нолик на клетку, пока не нажать кнопку рестарт->если же не конец то продолжаем-> мы получаем i(индекс, идентификатор) нажатой ячейки-> создаем новую команду c i ->помещаем команду в историю(история состоит из таких команд\шагов)-> отправляем по каналу сообщение, чтобы в других вкладках тоже добавился новый ход->и рендер, то есть отобразить ход на страничке браузера
const cellListener = (e) => {
  if (checkEndGame()) return;
  const { srcElement } = e;
  const i = srcElement.getAttribute('data-id');
  const com = new Command(history.state, i);
  history.push(com);
  MakeSync('render');
  render();
};
//тут все просто, нам нужно на все кнопки и квадратики повесить слушателей, которые будут вызываться при нажатии
const initListeners = () => {
  const cells = document.getElementsByClassName('cell'); //тут мы находим все ячейки\квадраты
  [...cells].forEach((cell) => {
    //проходимся по ним и навешиваем слушателя, то есть теперь при нажатии на квадрат будет вызываться функция cellListener
    cell.addEventListener('click', cellListener);
  });
  //ниже то же самое только для всех кнопок
  const undoBtn = document.getElementsByClassName('undo-btn')[0];
  undoBtn.onclick = undoBtnListener;
  const redoBtn = document.getElementsByClassName('redo-btn')[0];
  redoBtn.onclick = redoBtnListener;
  const restartBtn = document.getElementsByClassName('restart-btn')[0];
  restartBtn.onclick = restartBtnListener;
};
//вызывается сразу же при загрузке страницы, необходимо для синхронизации игры, логика такая: изначально игра пустая в новой вкладке->мы смотрим в нашем хранилище localStorage есть ли там данные об начатой игре(как мы помним localStorage общий для всех вкладок и мы с каждый ходом его синхронизируем с нашей историей)->если есть, то мы историю ходов с хранилища синхронизируем с нашей основной историей -> вызываем рендер и все ходы которые мы сделали на другой вкладке - отобразаться и тут
const initStart = () => {
  const Data = getData();
  if (Data.gameNow) {
    const _history = history.copy(Data.history, State(), Data.state, Data.current);
    history = _history;
    render();
  }
};
//точка входа в программу, первым делом при загрузке страницы, выполняется это
(() => {
  initStart(); //важное
  initListeners(); //важное

  Share.onmessage = ({ data }) => {
    //в начале файла index.js мы написали про каналы, тут роль канала принимать сообщения
    //тут все просто , у нас открыто две вкладки в браузере, нам нужно их синхронизировать(когда нажимаешь крестик в одной вкладке, он должен появитсья и в другой)
    //когда нажали крестик-> отправилось сообщение с помощью MakeSync-> тут прийом этого сообщения в другой вкладке-> И по скольку мы на каждом ходу записываем историю в хранилище, то мы во второй вкладке, где приняли сообщение, читаем с того хранилища историю-> заменяем ею основную историю -> и вызываем рендер ->появляются все ранее сделанные ходы на нашей вкладке
    //как и упоминали выше про типы в makeSync, они могут быть render,step,restart - все делают одно и тоже, кроме одного уточнения, если тип restart или step, то спрячется верхняя панель с надписью победителя и кнопкой рестарт, так как она не нужна сейчас на странице
    const Data = getData();
    const _history = history.copy(Data.history, State(), Data.state, Data.current);
    history = _history;
    (data === 'restart' || data === 'step') && hideElement('won-title');
    render();
  };
})();

function calculateWinner(squares) {
  const lines = [...WIN_LINES];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i].indexes;
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return lines[i];
    }
  }
  return null;
}
